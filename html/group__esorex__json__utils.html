<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESO Recipe Execution Tool: JSON Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ESO Recipe Execution Tool
   &#160;<span id="projectnumber">3.13.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">JSON Utilities</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structer__json__node.html">er_json_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structer__json__array__iterator.html">er_json_array_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6939278115bd47c63ff76e098e2ca43b"><td class="memItemLeft" align="right" valign="top">cpl_error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga6939278115bd47c63ff76e098e2ca43b">er_frameset_to_json</a> (const cpl_frameset *frameset, const char *json_file)</td></tr>
<tr class="memdesc:ga6939278115bd47c63ff76e098e2ca43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a JSON file with the contents of a frameset.  <a href="group__esorex__json__utils.html#ga6939278115bd47c63ff76e098e2ca43b">More...</a><br /></td></tr>
<tr class="separator:ga6939278115bd47c63ff76e098e2ca43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa46a2b240a921220d6c4b4d7d4bdfd50"><td class="memItemLeft" align="right" valign="top">cpl_error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#gaa46a2b240a921220d6c4b4d7d4bdfd50">er_frameset_to_text</a> (const cpl_frameset *frameset, const char *text_file)</td></tr>
<tr class="memdesc:gaa46a2b240a921220d6c4b4d7d4bdfd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a text file with the contents of a frameset.  <a href="group__esorex__json__utils.html#gaa46a2b240a921220d6c4b4d7d4bdfd50">More...</a><br /></td></tr>
<tr class="separator:gaa46a2b240a921220d6c4b4d7d4bdfd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8dac41bec8a139b6b3a702e196fda74"><td class="memItemLeft" align="right" valign="top">cpl_error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#gac8dac41bec8a139b6b3a702e196fda74">er_recipe_parameterlist_to_json</a> (const cpl_parameterlist *plist, const char *recipe_name, const char *json_file)</td></tr>
<tr class="memdesc:gac8dac41bec8a139b6b3a702e196fda74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a JSON file with the contents of a parameterlist.  <a href="group__esorex__json__utils.html#gac8dac41bec8a139b6b3a702e196fda74">More...</a><br /></td></tr>
<tr class="separator:gac8dac41bec8a139b6b3a702e196fda74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade61bd6758231b0fefb709bb946ed11e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#gade61bd6758231b0fefb709bb946ed11e">er_plugin_to_json</a> (const cpl_plugin *plugin)</td></tr>
<tr class="memdesc:gade61bd6758231b0fefb709bb946ed11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialises a CPL plugin object to JSON text.  <a href="group__esorex__json__utils.html#gade61bd6758231b0fefb709bb946ed11e">More...</a><br /></td></tr>
<tr class="separator:gade61bd6758231b0fefb709bb946ed11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97837c8b3738028af649446dd08e7888"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga97837c8b3738028af649446dd08e7888">er_json_node_delete</a> (<a class="el" href="structer__json__node.html">er_json_node</a> *obj)</td></tr>
<tr class="memdesc:ga97837c8b3738028af649446dd08e7888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a parse tree JSON node returned by <a class="el" href="group__esorex__json__utils.html#ga0bdbd69cce03ee6a7ac8a17cbd1bf509" title="Parses a JSON text and produces a corresponding parse tree.">er_json_parse()</a>.  <a href="group__esorex__json__utils.html#ga97837c8b3738028af649446dd08e7888">More...</a><br /></td></tr>
<tr class="separator:ga97837c8b3738028af649446dd08e7888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42d1faedb3b5b83bb6285ca3e5a02784"><td class="memItemLeft" align="right" valign="top">er_json_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784">er_json_node_type</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj)</td></tr>
<tr class="memdesc:ga42d1faedb3b5b83bb6285ca3e5a02784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type of the JSON node.  <a href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784">More...</a><br /></td></tr>
<tr class="separator:ga42d1faedb3b5b83bb6285ca3e5a02784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f604d56e12ab88392573916e5d25818"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga7f604d56e12ab88392573916e5d25818">er_json_node_location</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj)</td></tr>
<tr class="memdesc:ga7f604d56e12ab88392573916e5d25818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's location in the original JSON text.  <a href="group__esorex__json__utils.html#ga7f604d56e12ab88392573916e5d25818">More...</a><br /></td></tr>
<tr class="separator:ga7f604d56e12ab88392573916e5d25818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2657f723f89ea5d1039d2915b8203968"><td class="memItemLeft" align="right" valign="top">cpl_boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga2657f723f89ea5d1039d2915b8203968">er_json_node_get_bool</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj)</td></tr>
<tr class="memdesc:ga2657f723f89ea5d1039d2915b8203968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the boolean value for a JSON node.  <a href="group__esorex__json__utils.html#ga2657f723f89ea5d1039d2915b8203968">More...</a><br /></td></tr>
<tr class="separator:ga2657f723f89ea5d1039d2915b8203968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf675b1eed91ac8ff85e68de0ef520d89"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#gaf675b1eed91ac8ff85e68de0ef520d89">er_json_node_get_number</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj)</td></tr>
<tr class="memdesc:gaf675b1eed91ac8ff85e68de0ef520d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number value for a JSON node.  <a href="group__esorex__json__utils.html#gaf675b1eed91ac8ff85e68de0ef520d89">More...</a><br /></td></tr>
<tr class="separator:gaf675b1eed91ac8ff85e68de0ef520d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aa79f3368869d10cd6727eabe03d184"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga4aa79f3368869d10cd6727eabe03d184">er_json_node_get_string</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj)</td></tr>
<tr class="memdesc:ga4aa79f3368869d10cd6727eabe03d184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string value for a JSON node.  <a href="group__esorex__json__utils.html#ga4aa79f3368869d10cd6727eabe03d184">More...</a><br /></td></tr>
<tr class="separator:ga4aa79f3368869d10cd6727eabe03d184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c6072de5d99b518dbe92039689ce311"><td class="memItemLeft" align="right" valign="top">cpl_size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga2c6072de5d99b518dbe92039689ce311">er_json_node_array_size</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj)</td></tr>
<tr class="memdesc:ga2c6072de5d99b518dbe92039689ce311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of an array node.  <a href="group__esorex__json__utils.html#ga2c6072de5d99b518dbe92039689ce311">More...</a><br /></td></tr>
<tr class="separator:ga2c6072de5d99b518dbe92039689ce311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeee38c99aabbfdd16fb8e416c56a9a6"><td class="memItemLeft" align="right" valign="top">cpl_boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#gadeee38c99aabbfdd16fb8e416c56a9a6">er_json_node_array_empty</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj)</td></tr>
<tr class="memdesc:gadeee38c99aabbfdd16fb8e416c56a9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the array node is empty or not.  <a href="group__esorex__json__utils.html#gadeee38c99aabbfdd16fb8e416c56a9a6">More...</a><br /></td></tr>
<tr class="separator:gadeee38c99aabbfdd16fb8e416c56a9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702870005176978e22ca1fa7d6272451"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structer__json__array__iterator.html">er_json_array_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga702870005176978e22ca1fa7d6272451">er_json_node_array_begin</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj)</td></tr>
<tr class="memdesc:ga702870005176978e22ca1fa7d6272451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an iterator to the first element of the array.  <a href="group__esorex__json__utils.html#ga702870005176978e22ca1fa7d6272451">More...</a><br /></td></tr>
<tr class="separator:ga702870005176978e22ca1fa7d6272451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca62714f58323ae9c6ed211fbc7e67c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structer__json__array__iterator.html">er_json_array_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#gaca62714f58323ae9c6ed211fbc7e67c6">er_json_node_array_end</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj)</td></tr>
<tr class="memdesc:gaca62714f58323ae9c6ed211fbc7e67c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an iterator pointing to one past the last element of the array.  <a href="group__esorex__json__utils.html#gaca62714f58323ae9c6ed211fbc7e67c6">More...</a><br /></td></tr>
<tr class="separator:gaca62714f58323ae9c6ed211fbc7e67c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcdc51623e6a7b98b121bb4cf1fa2718"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structer__json__array__iterator.html">er_json_array_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#gadcdc51623e6a7b98b121bb4cf1fa2718">er_json_node_array_next</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj, <a class="el" href="structer__json__array__iterator.html">er_json_array_iterator</a> current)</td></tr>
<tr class="memdesc:gadcdc51623e6a7b98b121bb4cf1fa2718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves to the next position in an array.  <a href="group__esorex__json__utils.html#gadcdc51623e6a7b98b121bb4cf1fa2718">More...</a><br /></td></tr>
<tr class="separator:gadcdc51623e6a7b98b121bb4cf1fa2718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0387f4dfa4503145523d02c44c7c93da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structer__json__array__iterator.html">er_json_array_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga0387f4dfa4503145523d02c44c7c93da">er_json_node_array_previous</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj, <a class="el" href="structer__json__array__iterator.html">er_json_array_iterator</a> current)</td></tr>
<tr class="memdesc:ga0387f4dfa4503145523d02c44c7c93da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves to the previous position in an array.  <a href="group__esorex__json__utils.html#ga0387f4dfa4503145523d02c44c7c93da">More...</a><br /></td></tr>
<tr class="separator:ga0387f4dfa4503145523d02c44c7c93da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8712b22574ddd7d60e4d1b579648476"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#gaa8712b22574ddd7d60e4d1b579648476">er_json_node_array_get</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj, <a class="el" href="structer__json__array__iterator.html">er_json_array_iterator</a> iterator)</td></tr>
<tr class="memdesc:gaa8712b22574ddd7d60e4d1b579648476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the corresponding array item pointed to by an iterator.  <a href="group__esorex__json__utils.html#gaa8712b22574ddd7d60e4d1b579648476">More...</a><br /></td></tr>
<tr class="separator:gaa8712b22574ddd7d60e4d1b579648476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fa957db15569054ea3591c678b4fb61"><td class="memItemLeft" align="right" valign="top">cpl_size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga5fa957db15569054ea3591c678b4fb61">er_json_node_object_size</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj)</td></tr>
<tr class="memdesc:ga5fa957db15569054ea3591c678b4fb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of an object node.  <a href="group__esorex__json__utils.html#ga5fa957db15569054ea3591c678b4fb61">More...</a><br /></td></tr>
<tr class="separator:ga5fa957db15569054ea3591c678b4fb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e0f65a1a0b584fd0c4dd54e370b0588"><td class="memItemLeft" align="right" valign="top">cpl_boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga5e0f65a1a0b584fd0c4dd54e370b0588">er_json_node_object_empty</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj)</td></tr>
<tr class="memdesc:ga5e0f65a1a0b584fd0c4dd54e370b0588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the object node is empty or not.  <a href="group__esorex__json__utils.html#ga5e0f65a1a0b584fd0c4dd54e370b0588">More...</a><br /></td></tr>
<tr class="separator:ga5e0f65a1a0b584fd0c4dd54e370b0588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979a9fc0219d13dcc5d40d114aad8253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga979a9fc0219d13dcc5d40d114aad8253">er_json_node_object_begin</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj)</td></tr>
<tr class="memdesc:ga979a9fc0219d13dcc5d40d114aad8253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an iterator to the first attribute of the object.  <a href="group__esorex__json__utils.html#ga979a9fc0219d13dcc5d40d114aad8253">More...</a><br /></td></tr>
<tr class="separator:ga979a9fc0219d13dcc5d40d114aad8253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa45cf8a69033bc80e2c64e5cdececaf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#gaa45cf8a69033bc80e2c64e5cdececaf9">er_json_node_object_end</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj)</td></tr>
<tr class="memdesc:gaa45cf8a69033bc80e2c64e5cdececaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an iterator pointing to one past the last attribute of the object.  <a href="group__esorex__json__utils.html#gaa45cf8a69033bc80e2c64e5cdececaf9">More...</a><br /></td></tr>
<tr class="separator:gaa45cf8a69033bc80e2c64e5cdececaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f0bd2156fe100462783f9b7869b3421"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga3f0bd2156fe100462783f9b7869b3421">er_json_node_object_next</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj, <a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a> current)</td></tr>
<tr class="memdesc:ga3f0bd2156fe100462783f9b7869b3421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves to the next attribute in an object.  <a href="group__esorex__json__utils.html#ga3f0bd2156fe100462783f9b7869b3421">More...</a><br /></td></tr>
<tr class="separator:ga3f0bd2156fe100462783f9b7869b3421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cefb488df2d5a4b0d9c7935bde06f21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga7cefb488df2d5a4b0d9c7935bde06f21">er_json_node_object_previous</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj, <a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a> current)</td></tr>
<tr class="memdesc:ga7cefb488df2d5a4b0d9c7935bde06f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves to the previous attribute in an object.  <a href="group__esorex__json__utils.html#ga7cefb488df2d5a4b0d9c7935bde06f21">More...</a><br /></td></tr>
<tr class="separator:ga7cefb488df2d5a4b0d9c7935bde06f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac434fc65d861c13792eaeeefa17edd38"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#gac434fc65d861c13792eaeeefa17edd38">er_json_node_object_get_key</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj, <a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a> iterator)</td></tr>
<tr class="memdesc:gac434fc65d861c13792eaeeefa17edd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the corresponding attribute name pointed to by an iterator.  <a href="group__esorex__json__utils.html#gac434fc65d861c13792eaeeefa17edd38">More...</a><br /></td></tr>
<tr class="separator:gac434fc65d861c13792eaeeefa17edd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga284e7a9e883e6430f3773184e6ef2e69"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga284e7a9e883e6430f3773184e6ef2e69">er_json_node_object_get_value</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj, <a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a> iterator)</td></tr>
<tr class="memdesc:ga284e7a9e883e6430f3773184e6ef2e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the corresponding attribute value pointed to by an iterator.  <a href="group__esorex__json__utils.html#ga284e7a9e883e6430f3773184e6ef2e69">More...</a><br /></td></tr>
<tr class="separator:ga284e7a9e883e6430f3773184e6ef2e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0617ca7997f949552cde782c000ecc9f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga0617ca7997f949552cde782c000ecc9f">er_json_node_object_get</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *obj, const char *key)</td></tr>
<tr class="memdesc:ga0617ca7997f949552cde782c000ecc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the value for a particular attribute in an object node.  <a href="group__esorex__json__utils.html#ga0617ca7997f949552cde782c000ecc9f">More...</a><br /></td></tr>
<tr class="separator:ga0617ca7997f949552cde782c000ecc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b9d64176470c76da7291205b60bd310"><td class="memItemLeft" align="right" valign="top">cpl_error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga4b9d64176470c76da7291205b60bd310">er_json_find_line_column</a> (const char *json, const char *location, int *line, int *column)</td></tr>
<tr class="memdesc:ga4b9d64176470c76da7291205b60bd310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds line and column numbers for a character position within a text.  <a href="group__esorex__json__utils.html#ga4b9d64176470c76da7291205b60bd310">More...</a><br /></td></tr>
<tr class="separator:ga4b9d64176470c76da7291205b60bd310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bdbd69cce03ee6a7ac8a17cbd1bf509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga0bdbd69cce03ee6a7ac8a17cbd1bf509">er_json_parse</a> (const char *json)</td></tr>
<tr class="memdesc:ga0bdbd69cce03ee6a7ac8a17cbd1bf509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a JSON text and produces a corresponding parse tree.  <a href="group__esorex__json__utils.html#ga0bdbd69cce03ee6a7ac8a17cbd1bf509">More...</a><br /></td></tr>
<tr class="separator:ga0bdbd69cce03ee6a7ac8a17cbd1bf509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043369d26269e450f1f63c4796c83dec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structer__stringarray__t.html">er_stringarray_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__esorex__json__utils.html#ga043369d26269e450f1f63c4796c83dec">er_json_to_string_array</a> (const <a class="el" href="structer__json__node.html">er_json_node</a> *parsetree, const char *json)</td></tr>
<tr class="memdesc:ga043369d26269e450f1f63c4796c83dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a parsed JSON array node into a <a class="el" href="structer__stringarray__t.html">er_stringarray_t</a> object.  <a href="group__esorex__json__utils.html#ga043369d26269e450f1f63c4796c83dec">More...</a><br /></td></tr>
<tr class="separator:ga043369d26269e450f1f63c4796c83dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module allows to write some CPL objects to JSON format. There is a recursive descent parser provided that also allows to parse JSON text into a parse tree. The parser should be compatible with UTF-8 and has an expanded number range, specifically NaN and infinity are accepted. Additional utility functions provide conversion of the parse tree back into CPL objects.</p>
<dl class="section user"><dt>Synopsis:</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;er_json.h&gt;</span></div>
</div><!-- fragment --> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6939278115bd47c63ff76e098e2ca43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6939278115bd47c63ff76e098e2ca43b">&#9670;&nbsp;</a></span>er_frameset_to_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_error_code er_frameset_to_json </td>
          <td>(</td>
          <td class="paramtype">const cpl_frameset *&#160;</td>
          <td class="paramname"><em>frameset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>json_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a JSON file with the contents of a frameset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameset</td><td>The frameset to export </td></tr>
    <tr><td class="paramname">json_file</td><td>Name of the JSON file to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<p>This function will export the content of a frameset to a JSON format which can be machine readable. The format looks like: </p><pre>
[
 {
   "name": "ifu_trace.fits",
   "category": "IFU_TRACE"
 },
 {
   "name": "ifu_transmission.fits",
   "category": "IFU_TRANSMISSION"
 }
]
</pre> 
</div>
</div>
<a id="gaa46a2b240a921220d6c4b4d7d4bdfd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa46a2b240a921220d6c4b4d7d4bdfd50">&#9670;&nbsp;</a></span>er_frameset_to_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_error_code er_frameset_to_text </td>
          <td>(</td>
          <td class="paramtype">const cpl_frameset *&#160;</td>
          <td class="paramname"><em>frameset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a text file with the contents of a frameset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameset</td><td>The frameset to export </td></tr>
    <tr><td class="paramname">text_file</td><td>Name of the JSON file to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<p>This function will export the contents of the frameset to a text human readable file, like the one used for the input sof. The output will look like this: </p><pre>
ifu_trace.fits     IFU_TRACE
ifu_transmission.fits     IFU_TRANSMISSION
</pre> 
</div>
</div>
<a id="ga4b9d64176470c76da7291205b60bd310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b9d64176470c76da7291205b60bd310">&#9670;&nbsp;</a></span>er_json_find_line_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_error_code er_json_find_line_column </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds line and column numbers for a character position within a text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">json</td><td>Original JSON text. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>A character position in the text, i.e. within <code>json</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">line</td><td>Pointer to an integer that will contain the computed line number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">column</td><td>Pointer to an integer that will contain the computed column number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success, or an appropriate error code if the input pointers were not valid.</dd></dl>
<p>This function will compute the line and column number corresponding to the given character location within the JSON text. </p>

</div>
</div>
<a id="ga702870005176978e22ca1fa7d6272451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga702870005176978e22ca1fa7d6272451">&#9670;&nbsp;</a></span>er_json_node_array_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structer__json__array__iterator.html">er_json_array_iterator</a> er_json_node_array_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an iterator to the first element of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to query. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_ARRAY</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointer or <code>NULL</code> if this node is not valid. A CPL error is set if an error occurs.</dd></dl>
<p>For an array type node this function returns an iterator to the first element of the array. </p>

</div>
</div>
<a id="gadeee38c99aabbfdd16fb8e416c56a9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeee38c99aabbfdd16fb8e416c56a9a6">&#9670;&nbsp;</a></span>er_json_node_array_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_boolean er_json_node_array_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the array node is empty or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to query. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_ARRAY</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_TRUE</code> if the array is empty or <code>CPL_FALSE</code> otherwise. If the node is not valid <code>CPL_FALSE</code> is returned and one should check this error condition with <code>cpl_error_get_code()</code>.</dd></dl>
<p>For array type JSON nodes this function will test if the array is empty. </p>

</div>
</div>
<a id="gaca62714f58323ae9c6ed211fbc7e67c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca62714f58323ae9c6ed211fbc7e67c6">&#9670;&nbsp;</a></span>er_json_node_array_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structer__json__array__iterator.html">er_json_array_iterator</a> er_json_node_array_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an iterator pointing to one past the last element of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to query. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_ARRAY</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointer or <code>NULL</code> if this node is not valid. A CPL error is set if an error occurs.</dd></dl>
<p>For an array type node this function returns an iterator marking a position that is one element past the end of the array. This allows to construct the following kind of iteration loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="structer__json__array__iterator.html">er_json_array_iterator</a> iter = <a class="code" href="group__esorex__json__utils.html#ga702870005176978e22ca1fa7d6272451">er_json_node_array_begin</a>(obj);</div>
<div class="line">     iter != <a class="code" href="group__esorex__json__utils.html#gaca62714f58323ae9c6ed211fbc7e67c6">er_json_node_array_end</a>(obj);</div>
<div class="line">     iter = <a class="code" href="group__esorex__json__utils.html#gadcdc51623e6a7b98b121bb4cf1fa2718">er_json_node_array_next</a>(obj, iter))</div>
<div class="line">{</div>
<div class="line">   ...</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaa8712b22574ddd7d60e4d1b579648476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8712b22574ddd7d60e4d1b579648476">&#9670;&nbsp;</a></span>er_json_node_array_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structer__json__node.html">er_json_node</a>* er_json_node_array_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structer__json__array__iterator.html">er_json_array_iterator</a>&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the corresponding array item pointed to by an iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to from which <code>iterator</code> was created. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_ARRAY</code>. </td></tr>
    <tr><td class="paramname">iterator</td><td>The iterator object pointing to the item of interest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The child JSON node item or <code>NULL</code> if the iterator or parent array node is invalid. A CPL error is set if an error occurs.</dd></dl>
<p>For array type nodes this function returns the child item pointed to by the given iterator. The iterator must have been created from the given array node. </p>

</div>
</div>
<a id="gadcdc51623e6a7b98b121bb4cf1fa2718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcdc51623e6a7b98b121bb4cf1fa2718">&#9670;&nbsp;</a></span>er_json_node_array_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structer__json__array__iterator.html">er_json_array_iterator</a> er_json_node_array_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structer__json__array__iterator.html">er_json_array_iterator</a>&#160;</td>
          <td class="paramname"><em>current</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves to the next position in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to from which <code>current</code> was created. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_ARRAY</code>. </td></tr>
    <tr><td class="paramname">current</td><td>The iterator object being incremented.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The incremented iterator or <code>NULL</code> if the current iterator or array node is invalid. A CPL error is set if an error occurs.</dd></dl>
<p>For array type nodes this will increment an iterator object that was created from the node. i.e. move the iterator to the next position in the array. </p>

</div>
</div>
<a id="ga0387f4dfa4503145523d02c44c7c93da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0387f4dfa4503145523d02c44c7c93da">&#9670;&nbsp;</a></span>er_json_node_array_previous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structer__json__array__iterator.html">er_json_array_iterator</a> er_json_node_array_previous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structer__json__array__iterator.html">er_json_array_iterator</a>&#160;</td>
          <td class="paramname"><em>current</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves to the previous position in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to from which <code>current</code> was created. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_ARRAY</code>. </td></tr>
    <tr><td class="paramname">current</td><td>The iterator object being decremented.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decremented iterator or <code>NULL</code> if the current iterator or array node is invalid. A CPL error is set if an error occurs.</dd></dl>
<p>For array type nodes this will decrement an iterator object that was created from the node. i.e. move the iterator to the previous position in the array. </p>

</div>
</div>
<a id="ga2c6072de5d99b518dbe92039689ce311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c6072de5d99b518dbe92039689ce311">&#9670;&nbsp;</a></span>er_json_node_array_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_size er_json_node_array_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of an array node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to query. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_ARRAY</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the array or <code>-1</code> if the node is not valid. A CPL error is set if an error occurs.</dd></dl>
<p>For array type JSON nodes this will return the number of elements in the array. </p>

</div>
</div>
<a id="ga97837c8b3738028af649446dd08e7888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97837c8b3738028af649446dd08e7888">&#9670;&nbsp;</a></span>er_json_node_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void er_json_node_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a parse tree JSON node returned by <a class="el" href="group__esorex__json__utils.html#ga0bdbd69cce03ee6a7ac8a17cbd1bf509" title="Parses a JSON text and produces a corresponding parse tree.">er_json_parse()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The parse tree object to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<p>This function must be called on the resultant object from a call to the <a class="el" href="group__esorex__json__utils.html#ga0bdbd69cce03ee6a7ac8a17cbd1bf509" title="Parses a JSON text and produces a corresponding parse tree.">er_json_parse()</a> function when it is no longer needed. This will free the allocated buffers. </p>

</div>
</div>
<a id="ga2657f723f89ea5d1039d2915b8203968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2657f723f89ea5d1039d2915b8203968">&#9670;&nbsp;</a></span>er_json_node_get_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_boolean er_json_node_get_bool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the boolean value for a JSON node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to query. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_BOOL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>CPL_TRUE</code> or <code>CPL_FALSE</code> value. If this was not a valid node then <code>CPL_FALSE</code> is returned by default, <code>cpl_error_get_code()</code> can be used to check for such errors.</dd></dl>
<p>For boolean JSON nodes this function will return its value as a <code>cpl_boolean</code>. </p>

</div>
</div>
<a id="gaf675b1eed91ac8ff85e68de0ef520d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf675b1eed91ac8ff85e68de0ef520d89">&#9670;&nbsp;</a></span>er_json_node_get_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double er_json_node_get_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number value for a JSON node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to query. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_NUMBER</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The floating point value or NaN (Not a Number) if this was not a valid node. <code>cpl_error_get_code()</code> can be used to check if the node really contains a NaN value or if it was in fact invalid.</dd></dl>
<p>For a number type JSON node this function will return its value as a double precision floating point number. </p>

</div>
</div>
<a id="ga4aa79f3368869d10cd6727eabe03d184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4aa79f3368869d10cd6727eabe03d184">&#9670;&nbsp;</a></span>er_json_node_get_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* er_json_node_get_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the string value for a JSON node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to query. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_STRING</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string value or <code>NULL</code> if the node is not valid. A CPL error is set if an error occurs.</dd></dl>
<p>For a string type JSON node this function will return its value as a null terminated character string. </p>

</div>
</div>
<a id="ga7f604d56e12ab88392573916e5d25818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f604d56e12ab88392573916e5d25818">&#9670;&nbsp;</a></span>er_json_node_location()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* er_json_node_location </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the node's location in the original JSON text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string position within the original JSON text or <code>NULL</code> if this node is not valid. A CPL error is set if an error occurs.</dd></dl>
<p>Returns the string location within the original JSON text that this JSON node was parsed from. Allows to calculate the line and column numbers for error messages using <a class="el" href="group__esorex__json__utils.html#ga4b9d64176470c76da7291205b60bd310" title="Finds line and column numbers for a character position within a text.">er_json_find_line_column()</a>. </p>

</div>
</div>
<a id="ga979a9fc0219d13dcc5d40d114aad8253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga979a9fc0219d13dcc5d40d114aad8253">&#9670;&nbsp;</a></span>er_json_node_object_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a> er_json_node_object_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an iterator to the first attribute of the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to query. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_OBJECT</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointer or <code>NULL</code> if this node is not valid. A CPL error is set if an error occurs.</dd></dl>
<p>For an object type node this function returns an iterator to the first attribute of the object. </p>

</div>
</div>
<a id="ga5e0f65a1a0b584fd0c4dd54e370b0588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e0f65a1a0b584fd0c4dd54e370b0588">&#9670;&nbsp;</a></span>er_json_node_object_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_boolean er_json_node_object_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the object node is empty or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to query. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_OBJECT</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_TRUE</code> if the object has no attributes or <code>CPL_FALSE</code> otherwise. If the node is not valid <code>CPL_FALSE</code> is returned and one should check this error condition with <code>cpl_error_get_code()</code>.</dd></dl>
<p>For object type JSON nodes this function will test if the object contains any attributes. </p>

</div>
</div>
<a id="gaa45cf8a69033bc80e2c64e5cdececaf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa45cf8a69033bc80e2c64e5cdececaf9">&#9670;&nbsp;</a></span>er_json_node_object_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a> er_json_node_object_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an iterator pointing to one past the last attribute of the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to query. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_OBJECT</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointer or <code>NULL</code> if this node is not valid. A CPL error is set if an error occurs.</dd></dl>
<p>For an object type node this function returns an iterator marking a position that is one attribute past the end of the object's attribute list. This allows to construct the following kind of iteration loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="structer__json__object__iterator.html">er_json_object_iterator</a> iter = <a class="code" href="group__esorex__json__utils.html#ga979a9fc0219d13dcc5d40d114aad8253">er_json_node_object_begin</a>(obj);</div>
<div class="line">     iter != <a class="code" href="group__esorex__json__utils.html#gaa45cf8a69033bc80e2c64e5cdececaf9">er_json_node_object_end</a>(obj);</div>
<div class="line">     iter = <a class="code" href="group__esorex__json__utils.html#ga3f0bd2156fe100462783f9b7869b3421">er_json_node_object_next</a>(obj, iter))</div>
<div class="line">{</div>
<div class="line">   ...</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga0617ca7997f949552cde782c000ecc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0617ca7997f949552cde782c000ecc9f">&#9670;&nbsp;</a></span>er_json_node_object_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structer__json__node.html">er_json_node</a>* er_json_node_object_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the value for a particular attribute in an object node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to query. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_OBJECT</code>. </td></tr>
    <tr><td class="paramname">key</td><td>The name of the attribute to search for in the object node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute's value node or <code>NULL</code> if no such attribute exists. If the parent node being queries is not valid then <code>NULL</code> is also returned and an error code is set, which can be queried with <code>cpl_error_get_code()</code>.</dd></dl>
<p>This function will try to find an attribute in an object type JSON node. The attribute is named by the given key. If such an attribute is found it's corresponding value is returned or <code>NULL</code> if no such attribute can be found. </p>

</div>
</div>
<a id="gac434fc65d861c13792eaeeefa17edd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac434fc65d861c13792eaeeefa17edd38">&#9670;&nbsp;</a></span>er_json_node_object_get_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* er_json_node_object_get_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a>&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the corresponding attribute name pointed to by an iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to from which <code>iterator</code> was created. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_OBJECT</code>. </td></tr>
    <tr><td class="paramname">iterator</td><td>The iterator object pointing to the attribute of interest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute name as a string, or <code>NULL</code> if the iterator or parent object node is invalid. A CPL error is set if an error occurs.</dd></dl>
<p>For object type nodes this function returns the key or attribute name pointed to by the given iterator. The iterator must have been created from the given object node. </p>

</div>
</div>
<a id="ga284e7a9e883e6430f3773184e6ef2e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga284e7a9e883e6430f3773184e6ef2e69">&#9670;&nbsp;</a></span>er_json_node_object_get_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structer__json__node.html">er_json_node</a>* er_json_node_object_get_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a>&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the corresponding attribute value pointed to by an iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to from which <code>iterator</code> was created. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_OBJECT</code>. </td></tr>
    <tr><td class="paramname">iterator</td><td>The iterator object pointing to the attribute of interest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute's value node object, or <code>NULL</code> if the iterator or parent node is invalid. A CPL error is set if an error occurs.</dd></dl>
<p>For object type nodes this function returns the attribute's value, pointed to by the given iterator. The iterator must have been created from the given object node. </p>

</div>
</div>
<a id="ga3f0bd2156fe100462783f9b7869b3421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f0bd2156fe100462783f9b7869b3421">&#9670;&nbsp;</a></span>er_json_node_object_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a> er_json_node_object_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a>&#160;</td>
          <td class="paramname"><em>current</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves to the next attribute in an object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to from which <code>current</code> was created. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_OBJECT</code>. </td></tr>
    <tr><td class="paramname">current</td><td>The iterator object being incremented.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The incremented iterator or <code>NULL</code> if the current iterator or object node is invalid. A CPL error is set if an error occurs.</dd></dl>
<p>For object type nodes this will increment an iterator object that was created from the node. i.e. move the iterator to the next position in the object's attribute list. </p>

</div>
</div>
<a id="ga7cefb488df2d5a4b0d9c7935bde06f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cefb488df2d5a4b0d9c7935bde06f21">&#9670;&nbsp;</a></span>er_json_node_object_previous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a> er_json_node_object_previous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structer__json__object__iterator.html">er_json_object_iterator</a>&#160;</td>
          <td class="paramname"><em>current</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves to the previous attribute in an object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to from which <code>current</code> was created. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_OBJECT</code>. </td></tr>
    <tr><td class="paramname">current</td><td>The iterator object being decremented.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decremented iterator or <code>NULL</code> if the current iterator or object node is invalid. A CPL error is set if an error occurs.</dd></dl>
<p>For object type nodes this will decrement an iterator object that was created from the node. i.e. move the iterator to the previous position in the object's attribute list. </p>

</div>
</div>
<a id="ga5fa957db15569054ea3591c678b4fb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fa957db15569054ea3591c678b4fb61">&#9670;&nbsp;</a></span>er_json_node_object_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_size er_json_node_object_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of an object node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to query. Must be a node with <a class="el" href="group__esorex__json__utils.html#ga42d1faedb3b5b83bb6285ca3e5a02784" title="Return the type of the JSON node.">er_json_node_type()</a> returning <code>JSON_OBJECT</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of attributes in the object or <code>-1</code> if the node is not valid. A CPL error is set if an error occurs.</dd></dl>
<p>For object type JSON nodes this will return the number of attributes for the object. </p>

</div>
</div>
<a id="ga42d1faedb3b5b83bb6285ca3e5a02784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42d1faedb3b5b83bb6285ca3e5a02784">&#9670;&nbsp;</a></span>er_json_node_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">er_json_type er_json_node_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the type of the JSON node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON node to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type code for this JSON node or <code>JSON_NULL</code> if <code>obj</code> is invalid. Must use <code>cpl_error_get_code()</code> to confirm if it was invalid.</dd></dl>
<p>This returns the type code that can be used to figure out what kind of JSON node one is dealing with. This is important to decide which functions can be used with this node. e.g. the array functions or object functions etc. Valid type codes returned by this function are one of the following: </p><ul>
<li>
JSON_NULL </li>
<li>
JSON_BOOL </li>
<li>
JSON_NUMBER </li>
<li>
JSON_STRING </li>
<li>
JSON_ARRAY </li>
<li>
JSON_OBJECT </li>
</ul>

</div>
</div>
<a id="ga0bdbd69cce03ee6a7ac8a17cbd1bf509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bdbd69cce03ee6a7ac8a17cbd1bf509">&#9670;&nbsp;</a></span>er_json_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structer__json__node.html">er_json_node</a>* er_json_parse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a JSON text and produces a corresponding parse tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The JSON null terminated text string to parse.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A JSON node object to the root of the parse tree, or <code>NULL</code> if there was a parse error. In that case a CPL error code with an appropriate message is set.</dd></dl>
<p>This function will parse the input JSON text string and produce a parse tree. The parse tree is a tree of <a class="el" href="structer__json__node.html">er_json_node</a> objects representing the parsed information. The tree can be navigated to extract the converted string, boolean and floating point number data. </p>

</div>
</div>
<a id="ga043369d26269e450f1f63c4796c83dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga043369d26269e450f1f63c4796c83dec">&#9670;&nbsp;</a></span>er_json_to_string_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structer__stringarray__t.html">er_stringarray_t</a>* er_json_to_string_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structer__json__node.html">er_json_node</a> *&#160;</td>
          <td class="paramname"><em>parsetree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>json</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a parsed JSON array node into a <a class="el" href="structer__stringarray__t.html">er_stringarray_t</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parsetree</td><td>The parse tree for the JSON text, as produced by the <a class="el" href="group__esorex__json__utils.html#ga0bdbd69cce03ee6a7ac8a17cbd1bf509" title="Parses a JSON text and produces a corresponding parse tree.">er_json_parse()</a> function. This can be a subnode of the result produced by <a class="el" href="group__esorex__json__utils.html#ga0bdbd69cce03ee6a7ac8a17cbd1bf509" title="Parses a JSON text and produces a corresponding parse tree.">er_json_parse()</a>. </td></tr>
    <tr><td class="paramname">json</td><td>The original JSON text from which the <code>parsetree</code> node was produced.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success or an appropriate error code otherwise.</dd></dl>
<p>Converts a JSON array node that is returned by the <a class="el" href="group__esorex__json__utils.html#ga0bdbd69cce03ee6a7ac8a17cbd1bf509" title="Parses a JSON text and produces a corresponding parse tree.">er_json_parse()</a> function, into a <a class="el" href="structer__stringarray__t.html">er_stringarray_t</a> object, which contains a list of strings. One of the subnodes of the resultant parse tree from <a class="el" href="group__esorex__json__utils.html#ga0bdbd69cce03ee6a7ac8a17cbd1bf509" title="Parses a JSON text and produces a corresponding parse tree.">er_json_parse()</a> can be used instead, if we only want to convert a child element from the JSON text. </p>

</div>
</div>
<a id="gade61bd6758231b0fefb709bb946ed11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade61bd6758231b0fefb709bb946ed11e">&#9670;&nbsp;</a></span>er_plugin_to_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* er_plugin_to_json </td>
          <td>(</td>
          <td class="paramtype">const cpl_plugin *&#160;</td>
          <td class="paramname"><em>plugin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialises a CPL plugin object to JSON text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plugin</td><td>The CPL plugin object to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The JSON test corresponding to the CPL plugin, otherwise <code>NULL</code> if an error occurred.</dd></dl>
<p>This function will produce JSON text that corresponds to a CPL plugin object. The following is an example of the produced JSON format: </p><pre>
{
  "class": "Recipe",
  "name": "somerecipe",
  "version": 10205,
  "synopsis": "recipe",
  "description": "This is a recipe",
  "author": "Some Author",
  "email": "someone@eso.org",
  "copyright": "copyright message",
  "parameters": [
    {
      "name": "somerecipe.par1",
      "class": "value",
      "id": 0,
      "description": "integer parameter",
      "context": "somerecipe",
      "value": 12,
      "default": 5,
      "present": false,
      "tag": null,
      "cli_enabled": true,
      "cli_alias": "somerecipe.par1",
      "env_enabled": true,
      "env_alias": "somerecipe.par1",
      "cfg_enabled": true,
      "cfg_alias": "somerecipe.par1"
    }
  ],
  "frames": [
    {
      "filename": "test.fits",
      "tag": "RAW",
      "type": 2,
      "group": 1,
      "level": 3
    }
  ]
}
</pre><dl class="section note"><dt>Note</dt><dd>The caller must free the result with <code>cpl_free()</code> once it is no longer needed. </dd></dl>

</div>
</div>
<a id="gac8dac41bec8a139b6b3a702e196fda74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8dac41bec8a139b6b3a702e196fda74">&#9670;&nbsp;</a></span>er_recipe_parameterlist_to_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpl_error_code er_recipe_parameterlist_to_json </td>
          <td>(</td>
          <td class="paramtype">const cpl_parameterlist *&#160;</td>
          <td class="paramname"><em>plist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>recipe_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>json_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a JSON file with the contents of a parameterlist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plist</td><td>The parameter list to export </td></tr>
    <tr><td class="paramname">recipe_name</td><td>The recipe this parameter list applies to </td></tr>
    <tr><td class="paramname">json_file</td><td>Name of the JSON file to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>CPL_ERROR_NONE</code> on success.</dd></dl>
<p>This function exports the content of a parameter list to a machine readable JSON format. The output looks like: </p><pre>
[
 {
   "name": "vimos.Parameters.stacking.singleframes",
   "value": true,
   "display_name": "AllowSingleFrames",
   "description": "Frame combination method is ignored.",
   "recipe": "vmbias"
 },
 {
   "name": "vimos.Parameters.stacking.method",
   "value": "Median",
   "display_name": "StackMethod",
   "description": "Frame combination method",
   "recipe": "vmbias"
 }
]
</pre> 
</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__esorex__json__utils_html_ga979a9fc0219d13dcc5d40d114aad8253"><div class="ttname"><a href="group__esorex__json__utils.html#ga979a9fc0219d13dcc5d40d114aad8253">er_json_node_object_begin</a></div><div class="ttdeci">er_json_object_iterator er_json_node_object_begin(const er_json_node *obj)</div><div class="ttdoc">Gets an iterator to the first attribute of the object.</div><div class="ttdef"><b>Definition:</b> er_json.c:1803</div></div>
<div class="ttc" id="astructer__json__object__iterator_html"><div class="ttname"><a href="structer__json__object__iterator.html">er_json_object_iterator</a></div></div>
<div class="ttc" id="agroup__esorex__json__utils_html_ga702870005176978e22ca1fa7d6272451"><div class="ttname"><a href="group__esorex__json__utils.html#ga702870005176978e22ca1fa7d6272451">er_json_node_array_begin</a></div><div class="ttdeci">er_json_array_iterator er_json_node_array_begin(const er_json_node *obj)</div><div class="ttdoc">Gets an iterator to the first element of the array.</div><div class="ttdef"><b>Definition:</b> er_json.c:1616</div></div>
<div class="ttc" id="agroup__esorex__json__utils_html_gaa45cf8a69033bc80e2c64e5cdececaf9"><div class="ttname"><a href="group__esorex__json__utils.html#gaa45cf8a69033bc80e2c64e5cdececaf9">er_json_node_object_end</a></div><div class="ttdeci">er_json_object_iterator er_json_node_object_end(const er_json_node *obj)</div><div class="ttdoc">Gets an iterator pointing to one past the last attribute of the object.</div><div class="ttdef"><b>Definition:</b> er_json.c:1835</div></div>
<div class="ttc" id="agroup__esorex__json__utils_html_ga3f0bd2156fe100462783f9b7869b3421"><div class="ttname"><a href="group__esorex__json__utils.html#ga3f0bd2156fe100462783f9b7869b3421">er_json_node_object_next</a></div><div class="ttdeci">er_json_object_iterator er_json_node_object_next(const er_json_node *obj, er_json_object_iterator current)</div><div class="ttdoc">Moves to the next attribute in an object.</div><div class="ttdef"><b>Definition:</b> er_json.c:1858</div></div>
<div class="ttc" id="astructer__json__array__iterator_html"><div class="ttname"><a href="structer__json__array__iterator.html">er_json_array_iterator</a></div></div>
<div class="ttc" id="agroup__esorex__json__utils_html_gadcdc51623e6a7b98b121bb4cf1fa2718"><div class="ttname"><a href="group__esorex__json__utils.html#gadcdc51623e6a7b98b121bb4cf1fa2718">er_json_node_array_next</a></div><div class="ttdeci">er_json_array_iterator er_json_node_array_next(const er_json_node *obj, er_json_array_iterator current)</div><div class="ttdoc">Moves to the next position in an array.</div><div class="ttdef"><b>Definition:</b> er_json.c:1669</div></div>
<div class="ttc" id="agroup__esorex__json__utils_html_gaca62714f58323ae9c6ed211fbc7e67c6"><div class="ttname"><a href="group__esorex__json__utils.html#gaca62714f58323ae9c6ed211fbc7e67c6">er_json_node_array_end</a></div><div class="ttdeci">er_json_array_iterator er_json_node_array_end(const er_json_node *obj)</div><div class="ttdoc">Gets an iterator pointing to one past the last element of the array.</div><div class="ttdef"><b>Definition:</b> er_json.c:1647</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
